package {{package}};

import {{invokerPackage}}.ApiException;
import {{invokerPackage}}.ApiInvoker;
import {{invokerPackage}}.SwaggerApi;

import {{modelPackage}}.*;

import java.util.*;
import java.util.concurrent.*;
import javax.ws.rs.core.Response;

import jersey.repackaged.com.google.common.util.concurrent.AsyncFunction;
import jersey.repackaged.com.google.common.util.concurrent.Futures;
import jersey.repackaged.com.google.common.util.concurrent.ListenableFuture;
import jersey.repackaged.com.google.common.util.concurrent.SettableFuture;

{{#imports}}import {{import}};
{{/imports}}

import javax.ws.rs.core.Form;
import javax.ws.rs.core.MediaType;

import java.io.File;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

{{#operations}}
public class {{classname}} extends SwaggerApi {
  public {{classname}}() {
    this("{{basePath}}", new ApiInvoker());
  }

  public {{classname}}(String basePath) {
    this(basePath, new ApiInvoker());
  }

  public {{classname}}(ApiInvoker apiInvoker) {
    this("{{basePath}}", apiInvoker);
  }

  public {{classname}}(String basePath, ApiInvoker apiInvoker) {
    this.basePath = basePath;
    this.apiInvoker = apiInvoker;
  }

  {{#operation}}
  {{#errorList}} //error info- code: {{code}} reason: "{{reason}}" model: {{#responseModel}}{{responseModel}}
  {{/responseModel}}{{^responseModel}}<none>
  {{/responseModel}}
  {{/errorList}}
  public {{#returnType}}Future<{{{returnType}}}>{{/returnType}}{{^returnType}}void{{/returnType}} {{nickname}}Async({{#allParams}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) throws Exception {
    Object postBody = {{#bodyParam}}{{paramName}}{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}};
    {{#requiredParamCount}}
    // verify required params are set
    if({{/requiredParamCount}}{{#requiredParams}} {{paramName}} == null {{#hasMore}}|| {{/hasMore}}{{/requiredParams}}{{#requiredParamCount}}) {
      throw new ApiException(400, "missing required params");
    }
    {{/requiredParamCount}}

    // create path and map variables
    String path = "{{path}}".replaceAll("\\{format\\}","json"){{#pathParams}}
      .replaceAll("\\{" + "{{paramName}}" + "\\}", apiInvoker.escapeString({{{paramName}}}.toString())){{/pathParams}};

    // query params
    Map<String, String> queryParams = new HashMap<String, String>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, String> formParams = new HashMap<String, String>();

    {{#queryParams}}if(!"null".equals(String.valueOf({{paramName}})))
      queryParams.put("{{baseName}}", String.valueOf({{paramName}}));
    {{/queryParams}}

    {{#headerParams}}headerParams.put("{{baseName}}", {{paramName}});{{/headerParams}}

    String[] contentTypes = {
    {{#consumes}}"{{mediaType}}"{{#hasMore}},{{/hasMore}}{{/consumes}}
    };

    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if(contentType.startsWith("multipart/form-data")) {
      boolean hasFields = false;
      Form form = new Form();
      {{#formParams}}
      {{#notFile}}
      hasFields = true;
      form.param("{{baseName}}", {{paramName}});
      {{/notFile}}
      {{#isFile}}
      hasFields = true;
      form.param("{{baseName}}", {{paramName}});
      {{/isFile}}
      {{/formParams}}
      if(hasFields) {
        postBody = form;
      }
      else {
        {{#formParams}}{{#notFile}}formParams.put("{{baseName}}", {{paramName}});{{/notFile}}{{/formParams}}
      }
    }

    try {
      ListenableFuture<Response> response = apiInvoker.invokeApiAsync(basePath, path, "{{httpMethod}}", queryParams, postBody, headerParams, formParams, contentType);
      {{#returnType}}
      return Futures.transform(response,
        new AsyncFunction<Response, {{{returnType}}}>() {
          @Override
          public ListenableFuture<{{{returnType}}}> apply(Response response) throws Exception {
            SettableFuture<{{{returnType}}}> future = SettableFuture.create();
            String responseString = apiInvoker.getResponseAsString(response);
            if (responseString == null) {
              future.set(null);
            } else {
              {{{returnType}}} result = ({{{returnType}}}) ApiInvoker.deserialize(responseString, "{{returnContainer}}", {{returnBaseType}}.class);
              future.set(result);
            }

            return future;
          }
        });
      {{/returnType}}
      {{^returnType}}
      return;
      {{/returnType}}
    } catch (ApiException ex) {
      if(ex.getCode() == 404) {
        return {{#returnType}}null{{/returnType}};
      } else {
        throw ex;
      }
    } catch (Exception ex) {
      Throwable cause = ex.getCause();

      if (cause instanceof ApiException) {
        ApiException apiException = (ApiException) cause;
        if(apiException.getCode() == 404) {
          return {{#returnType}}null{{/returnType}};
        } else {
          throw apiException;
        }
      }

      throw ex;
    }
  }

  public {{#returnType}}{{{returnType}}} {{/returnType}}{{^returnType}}void {{/returnType}}{{nickname}}({{#allParams}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) throws ApiException {
    Object postBody = {{#bodyParam}}{{paramName}}{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}};
    {{#requiredParamCount}}
    // verify required params are set
    if({{/requiredParamCount}}{{#requiredParams}} {{paramName}} == null {{#hasMore}}|| {{/hasMore}}{{/requiredParams}}{{#requiredParamCount}}) {
       throw new ApiException(400, "missing required params");
    }
    {{/requiredParamCount}}

    // create path and map variables
    String path = "{{path}}".replaceAll("\\{format\\}","json"){{#pathParams}}
      .replaceAll("\\{" + "{{paramName}}" + "\\}", apiInvoker.escapeString({{{paramName}}}.toString())){{/pathParams}};

    // query params
    Map<String, String> queryParams = new HashMap<String, String>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, String> formParams = new HashMap<String, String>();

    {{#queryParams}}if(!"null".equals(String.valueOf({{paramName}})))
      queryParams.put("{{baseName}}", String.valueOf({{paramName}}));
    {{/queryParams}}

    {{#headerParams}}headerParams.put("{{baseName}}", {{paramName}});
    {{/headerParams}}
    String[] contentTypes = {
      {{#consumes}}"{{mediaType}}"{{#hasMore}},{{/hasMore}}{{/consumes}}
    };

    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if(contentType.startsWith("multipart/form-data")) {
      boolean hasFields = false;
      Form form = new Form();
      {{#formParams}}
      {{#notFile}}
      hasFields = true;
      form.param("{{baseName}}", {{paramName}});
      {{/notFile}}
      {{#isFile}}
      hasFields = true;
      form.param("{{baseName}}", {{paramName}});
      {{/isFile}}
      {{/formParams}}
      if(hasFields)
        postBody = form;
    }
    else {
      {{#formParams}}{{#notFile}}formParams.put("{{baseName}}", {{paramName}});{{/notFile}}
      {{/formParams}}
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, "{{httpMethod}}", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return {{#returnType}}({{{returnType}}}) ApiInvoker.deserialize(response, "{{returnContainer}}", {{returnBaseType}}.class){{/returnType}};
      }
      else {
        return {{#returnType}}null{{/returnType}};
      }
    } catch (ApiException ex) {
      if(ex.getCode() == 404) {
      	return {{#returnType}} null{{/returnType}};
      }
      else {
        throw ex;
      }
    }
  }
  {{/operation}}
}
{{/operations}}
